#!/usr/bin/env python3

import urllib.parse
import functools
import requests
import logging

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

NON_VALUE_KEYS = ('status', 'count', 'message')


class ApiException(Exception):
    def __init__(self, resp):
        self.resp = resp
        self.code = resp.status_code
        self.message = resp.json()['message']
        super().__init__(self.message)


def api_call(http_method):
    def decorator(func):
        # func(route, **kwargs)
        def wrapper(self, route, *args, **kwargs):
            if http_method in ('POST', 'PUT', 'PATCH'):
                route = f"{self.parent.url}{route}"
            else:
                route = f"{self.parent.url}/{route}{'?' + urllib.parse.urlencode(kwargs) if kwargs else ''}"

            resp = func(self, route, **kwargs)

            # Raise an exception if the HTTP request failed.
            if resp.status_code >= 400:
                raise ApiException(resp)

            content_type = resp.headers.get("Content-Type")
            if content_type == 'application/json':
                content = resp.json()
                print(content)

                # Raise an exception if the status is not ok
                if content['status'] != 'ok':
                    raise ApiException(resp)

                # Remove all top-level keys that are not the actual "value" and
                # return only the "value".
                for key in NON_VALUE_KEYS:
                    try:
                        del(content[key])
                    except KeyError:
                        continue

                if content == {}:
                    return None
                elif len(content) != 1:
                    raise ApiException(resp)
                else:
                    value_key = list(content.keys())[0]
                    return content[value_key]

            elif content_type == 'image/png':
                return resp.content
            else:
                raise ValueError(content_type)

        return wrapper
    return decorator


class Endpoint:
    def __init__(self, parent):
        self.parent = parent

    @api_call('GET')
    def _get(self, route, **kwargs):
        return requests.get(route, headers={"X-Auth-Token": self.parent.token})

    @api_call('POST')
    def _post(self, route, **kwargs):
        return requests.post(route, json=kwargs, headers={"X-Auth-Token": self.parent.token})

    @api_call('PATCH')
    def _patch(self, route, **kwargs):
        return requests.patch(route, json=kwargs, headers={"X-Auth-Token": self.parent.token})

    @api_call('PUT')
    def _put(self, route, **kwargs):
        return requests.put(route, json=kwargs, headers={"X-Auth-Token": self.parent.token})

    @api_call('DELETE')
    def _delete(self, route, **kwargs):
        return requests.delete(route, headers={"X-Auth-Token": self.parent.token})

{% for category in parsed %}
class {{category['name']|pascalcase}}(Endpoint):

{% for ep in category['endpoints'] %}
   def {{ep['name']|snakecase}}(self{%if ep['required']%}, {{ep['required']|join(", ")}}{%endif%}{%if ep['optional']%}, {{ep['optional']|join("='', ")}}=''{%endif%}, **kwargs):
       # route={{ep['route']}}
       # required={{ep['required']}}
       # optional={{ep['optional']}}
       # method={{ep['method']}}
       route = f"""{{ep['route']|route_to_fstring}}"""
       return self._{{ep['method']|lower}}(route, **kwargs)

{% endfor %} {# for ep in category #}
{% endfor %} {# for category in parsed #}
    

class LibreNMS:

    def __init__(self, url, token):
        # verify_ssl and other possible arguments to the requests methods.
        self.url = url
        self.token = token
        self.devices = Devices(self)

{%- for category in parsed %}
        self.{{category['name']|snakecase}} = {{category['name']|pascalcase}}(self)
{%- endfor %} {# for category in parsed #}
